{"version":3,"sources":["../../../../../server/api/actions/users/update.js"],"names":["update","req","reqSecured","usersAllowedAttributes","Promise","resolve","reject","then","user","body","id","userOwnsResourceResult","redisKey","userData","userBeingUpdated","existingValue","RESOURCE_NOT_FOUND","UNAUTHORISED_WRITE","admin","otherUsersWithSameUname","filter","u","uname","length","error","errorMessage","password","hash","emailVerificationRequired","email","toLowerCase","emailVerified","emailFingerprint","updatedUser","err"],"mappings":"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","sourcesContent":["import { datumLoad, datumUpdate } from '../datum';\n\nimport usersAllowedAttributes from './usersAllowedAttributes';\n\nimport authentication from 'utils/authentication';\nimport { hash } from 'utils/hash';\nimport { find, emailFingerprint } from 'utils/find';\nimport { userOwnsResource } from 'utils/userOwnsResource';\nimport { sendEmailVerificationEmail } from 'utils/emailHelpers';\nimport { UNAUTHORISED_WRITE, RESOURCE_NOT_FOUND } from 'helpers/constants';\nimport reqSecure from 'utils/reqSecure';\n\nexport default function update(req) {\n  const reqSecured = reqSecure(req, usersAllowedAttributes);\n  return new Promise((resolve, reject) => {\n    authentication(reqSecured).then(\n      user => {\n        userOwnsResource('users', reqSecured.body.id, user).then(\n          userOwnsResourceResult => {\n            datumLoad({ redisKey: 'users' }).then(userData => {\n              const { existingValue: userBeingUpdated } = find(\n                userData,\n                reqSecured.body.id,\n              );\n              // Users should be able to update their own user\n              if (!userBeingUpdated) {\n                reject(RESOURCE_NOT_FOUND);\n                return;\n              }\n\n              if (!user) {\n                reject(UNAUTHORISED_WRITE);\n                return;\n              }\n\n              // The user editing must either be the user themselves, or an admin\n              if (!user.admin && !userOwnsResourceResult) {\n                reject(UNAUTHORISED_WRITE);\n                return;\n              }\n\n              // Only admins can upgrade someone to being admins!\n              if (reqSecured.body.admin && (!user || !user.admin)) {\n                reject(UNAUTHORISED_WRITE);\n                return;\n              }\n\n              const otherUsersWithSameUname = userData.filter(\n                u =>\n                  u.uname === reqSecured.body.uname &&\n                  u.id !== reqSecured.body.id,\n              );\n\n              // If another user already with the same username, we cannot allow it to be updated, as usernames must be unique\n              if (otherUsersWithSameUname.length > 0) {\n                reject({\n                  error: 'user already exists',\n                  errorMessage: 'A user with that username already exists',\n                });\n                return;\n              }\n\n              if (reqSecured.body.password) {\n                reqSecured.body.hash = hash(reqSecured.body.password);\n                reqSecured.body.password = null;\n              } else {\n                reqSecured.body.hash = userBeingUpdated.hash;\n              }\n\n              // IF USER EMAIL HAS CHANGED, IT NEED RE-VERIFYING\n              const emailVerificationRequired =\n                reqSecured.body.email !== userBeingUpdated.email;\n              if (emailVerificationRequired) {\n                reqSecured.body.email = reqSecured.body.email.toLowerCase();\n                reqSecured.body.emailVerified = false;\n                reqSecured.body.emailFingerprint = emailFingerprint(\n                  reqSecured.body.email,\n                );\n              } else {\n                reqSecured.body.emailFingerprint =\n                  userBeingUpdated.emailFingerprint;\n                reqSecured.body.emailVerified = userBeingUpdated.emailVerified;\n              }\n\n              datumUpdate({ redisKey: 'users' }, reqSecured).then(\n                updatedUser => {\n                  if (emailVerificationRequired) {\n                    sendEmailVerificationEmail(updatedUser);\n                  }\n                  resolve(updatedUser);\n                },\n              );\n            });\n          },\n        );\n      },\n      err => reject(err),\n    );\n  });\n}\n"],"file":"update.js"}